当前进度：2.2.2


## 第一章 Node简介

##### 1. 单线程与多线程

**Node 保持了JavaScript浏览器中单线程的特点。单线程最大的好处是不用像多行程那样处处在意状态的同步问题，没有死锁的存在。**


单线程同时存在这些问题：

- 无法利用多核CPU
- 错误会引起整个引用退出，引用的健壮性值得考验
- 大量计算占用CPU导致无继续调用异步I/O。


Node通过子进程 child_process的方式解决单线程中计算量大的问题。

##### 2. Node 的特点

- 异步IO
    + node 在低层构建了很多异步IO 的API，从文件读取都网络请求均是如此
    + 对于同步IO而言，他们的耗时是两个任务的耗时之和SUM（M，N），而异步IO，其耗时是MAX（M,N）
    + 异步IO的提出是期望IO的调用不再阻塞后续运算（CPU的调用），将原有等待IO的时间分配给其他需要（CPU）的业务去执行
- 基于事件的回调
    + node引入前端的事件机制，配置异步IO，将事件点暴露给业务逻辑。事件的编程方式具有轻量级、松沟壑、只关注事件点执行具体事务等优势。而回调也是最好的接受异步调用返回数据的方式。
- 单线程

异步IO调用示意图
![](./asserts/io.jpg)

## 第二章 Node的模块实现

##### 1. 模块标识

- 模块标识就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以. / ..开头的相对路径，或者是绝对路径。

- require在分析标识符时，对于标识符不包含扩展名的情况，Node会一次按.js,.node,.json次序补足扩展名。因此，对于.node,.json文件，带上扩展名，会加快文件定位的速度。

小驼峰命名：
第一个单词首字母小写，后面其他单词首字母大写，如 className, baseUtil


##### 2. Node的模块

Node的模块分为2类：

```html
- 核心模块：Node直接提供的模块，在Node源代码的编译过程中，已经编写成了二进制可执行文件， 在Node进程启动时，部分核心模块被直接加载在内容，其加载速度最快。如：fs，http，path
- 文件模块：文件模块在运行时动态加载，需要完整的【路径分析，文件定位，编译执行】过程，速度比核心模块慢。
```

#####  3. Node目录分析和包

文件定位的顺序： 缓存加载 > 核心模块 > 路径形式的文件模块 > 自定义模块（非核心模块，非路径形式的标识符）

 require()通过分析文件扩展名之后，可能没有找对对应的文件，此时，会将该文件名当做一个目录名称，并当做一个包处理。

 1. 在当前目录中查找package.json文件，JSON.parse解析包描述对象，取main属性对应的文件进行定位
 2. 如果没有package.json 文件或者文件内容出错，则node会将index作为默认文件名，并按照index.js,index.node,index.json的次序查找。
 3. 如果在目录分析的过程中没有成功定位任何文件，则进入下一个模块路径（上一级目录）进行查找。
 4. 如果模块路径都遍历完成，都未定位，则报错。


##### 4. Node,W3c,Commonjs ECMAScript之间的关系

![img](asserts/relation.png)

##  第十一章 产品化

####  11.3 性能

对于web应用而言，最直接有效的莫过于动静分离、多进程架构、分布式。其中涉及的几个拆分原则如下：

- 做专一的事
- 让擅长的工具做擅长的事情
- 将模型简化
- 将风险分离

除此之外，缓存也能带来极大的性能提升。

主要从这4个方面来处理。

-  动静分离
    +  node 尽管也能通过中间件实现静态文件服务，但是node处理静态文件的能力并不算突出。
    +  将图片、js、css和media资源引导到专业的静态文件服务器，让node只处理动态请求，如nginx，cdn。
-  启用缓存
    +  resis
    +  memcached
-  多进程架构
    + 由于node是通过自有模块构件http服务器，不像大多数服务器端技术那样有专门的文本容器（比如java有tomcat，php有nginx），所以需要开发者自己处理多进程的管理。
    + 工具有 pm2，cluster
-  读写分离
    + 就任意数据库而言，读取的速度远远高于写人的速度。而某些数据库在写入时为了保证数据一致性，会进行锁表操作，这同时会影响到读取的速度。某些系统为了提升性能，通常会进行数据库的读写分离，**将数据库进行主从设计**，这样**读数据操作不再受到写入的影响，降低了性能的影响**
